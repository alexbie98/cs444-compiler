#pragma once

#include <vector>
#include <utility>
#include "DFA.h"

using Production = std::pair<unsigned int, std::vector<unsigned int>>;

extern const Production PRODUCTIONS[];

enum SymbolType
{
    TERMINAL_TYPE = 0,
    NONTERMINAL_TYPE = TokenType::COUNT
};

enum NonterminalSymbols
{
    START_SYMBOL = SymbolType::NONTERMINAL_TYPE,
    NAME,
    SIMPLE_NAME,
    QUALIFIED_NAME,
    LITERAL,
    TYPE,
    REFERENCE_TYPE,
    BASIC_TYPE,
    NAMED_TYPE,
    ARRAY_TYPE,
    TYPE_LIST,
    COMPILER_UNIT,
    PACKAGE_DECLARATION,
    IMPORT_DECLARATIONS_OPT,
    IMPORT_DECLARATIONS,
    IMPORT_DECLARATION,
    TYPE_DECLARATION_OPT,
    TYPE_DECLARATION,
    MODIFIERS_OPT,
    MODIFIERS,
    MODIFIER,
    CLASS_DECLARATION,
    EXTENDS_OPT,
    INTERFACES_OPT,
    CLASS_BODY,
    CLASS_BODY_DECLARATIONS,
    CLASS_BODY_DECLARATION,
    CLASS_MEMBER_DECLARATION,
    FIELD_DECLARATION,
    METHOD_DECLARATION,
    METHOD_SIGNATURE,
    CONSTRUCTOR_DECLARATION,
    INTERFACE_DECLARATION,
    INTERFACE_EXTENDS_OPT,
    INTERFACE_BODY,
    INTERFACE_BODY_DECLARATIONS,
    INTERFACE_BODY_DECLARATION,
    INTERFACE_METHOD_DECLARATION,
    FORMAL_PARAMETERS,
    FORMAL_PARAMETERS_OPT,
    FORMAL_PARAMETER_LIST,
    FORMAL_PARAMETER,
    BLOCK,
    BLOCK_BODY,
    BLOCK_STATEMENTS,
    BLOCK_STATEMENT,
    LOCAL_VARIABLE_DECLARATION_STATEMENT,
    LOCAL_VARIABLE_DECLARATION,
    STATEMENT,
    OPEN_STATEMENT,
    CLOSED_STATEMENT,
    PAR_EXPRESSION,
    EXPRESSION_OPT,
    STATEMENT_EXPRESSION,
    FOR_INIT_OPT,
    FOR_INIT,
    FOR_UPDATE_OPT,
    FOR_UPDATE,
    PRIMARY,
    PRIMARY_NO_NEW_ARRAY,
    CLASS_INSTANCE_CREATION_EXPRESSION,
    ARRAY_CREATION_EXPRESSION,
    ARRAY_CREATOR_REST,
    CLASS_CREATOR_REST,
    ARGUMENTS_OPT,
    ARGUMENTS,
    EXPRESSION_LIST,
    FIELD_ACCESS,
    METHOD_CALL,
    ARRAY_ACCESS,
    UNARY_EXPRESSION,
    UNARY_NOT_MINUS,
    CAST_EXPRESSION,
    MULTIPLICATIVE_EXPRESSION,
    ADDITIVE_EXPRESSION,
    RELATIONAL_EXPRESSION,
    EQUALITY_EXPRESSION,
    AND_EXPRESSION,
    XOR_EXPRESSION,
    OR_EXPRESSION,
    EAGER_AND_EXPRESSION,
    EAGER_OR_EXPRESSION,
    ASSIGNMENT_EXPRESSION,
    ASSIGNMENT,
    EXPRESSION
};

constexpr SymbolType getSymbolType(unsigned int value)
{
    return (value > NONTERMINAL_TYPE) ? NONTERMINAL_TYPE : TERMINAL_TYPE;
}


int stateShift(int currState, int symbol);
int stateReduce(int currState, int symbol);
